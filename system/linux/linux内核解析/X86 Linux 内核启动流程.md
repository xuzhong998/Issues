# X86 Linux 内核启动流程

## 一. BIOS

​	将bootsec(在磁盘0扇区, 512字节和511字节是0x 55, 0xAA)拷贝到内存地址0x7C00位置, 然后跳转执行.

## 二. bootsect.s (拷贝代码)

### 1. 拷贝自己

将自己(0x7C00位置后的512字节)拷贝到内存0x90000位置, 然后跳转到标签go执行.
### 2. 拷贝setup

go标签: 
将磁盘扇区[2,5] 共4个扇区, 每个扇区512字节, 拷贝到0x90200位置, 然后设置栈顶为0x9FF00.

### 3.拷贝head及剩下的其他系统代码

把从硬盘第 6 个扇区开始往后的 240 个扇区，加载到内存 0x10000 处, 然后跳转0x90200执行setup.

![](D:\Issues\system\linux\bootsect.png)

## <a name="三. setup.s"></a>三. setup.s (获取参数,转移代码,模式转换)

### 1. 获取系统参数

将其放在0x90000开始位置

![](D:\Issues\system\linux\setup.png)

将余下的代码(head, main)换到位置0: 0x10000到0x90000代码拷贝到0x00000到0x80000, 因为这区间的代码(BIOS时拷贝)已经被拷贝后执行过了不需要了, 所以可以覆盖随意使用.

### 2. 进入保护模式: 

**通过更改cr0寄存器PE位开启(1)和关闭(0)保护模式**

```assembly
mov ax,#0x0001  ; protected mode (PE) bit
lmsw ax      ; This is it;
jmpi 0,8     ; jmp offset 0 of segment 8 (cs)
```

然后跳转 cs 段 0 偏移地址执行代码.

从实模式进入保护模式, 至此有了**中断描述符表**和**全局描述符表**, 内存管理改变的有:

#### ①. 内存地址计算方式: 

Old: 段基址+偏移地址

Now:段选择子->段描述符索引->全局描述符表->段描述符->段基址 + 偏移地址

![](D:\Issues\system\linux\setup2.png)

全局描述符表在setup.s的gdt标签处, 用**lgdt**    gdt_48 存于 gdtr寄存器中待使用.

```assembly
gdt:
    .word   0,0,0,0     ; dummy

    .word   0x07FF      ; 8Mb - limit=2047 (2048*4096=8Mb)
    .word   0x0000      ; base address=0
    .word   0x9A00      ; code read/exec
    .word   0x00C0      ; granularity=4096, 386

    .word   0x07FF      ; 8Mb - limit=2047 (2048*4096=8Mb)
    .word   0x0000      ; base address=0
    .word   0x9200      ; data read/write
    .word   0x00C0      ; granularity=4096, 386
```

有3个, dummy段 (空的), code段, 和data段

#### ②. 内存变化

![](D:\Issues\system\linux\setup3.png)

执行 cs 段 0 偏移代码(0+0 = 0)就是执行system全部代码, 进入head及全部代码

## 四. head.s 以及 剩下的全部代码(分页转换, 跳转main)

设置段基址为数据段(通过设置段寄存器的段描述符实现)
设置栈指针指向stack_start

### 1. 重载idt 与 gdt

然后重设数据段与栈(因为重载idt 与 gdt,所以要重复上面两个设置)

![](D:\Issues\system\linux\head.png)

###  2. 开启分页机制

**通过更改cr0寄存器PG位开启(1)和关闭(0)分页机制**
至此有了**页目录表**及**页表项**, 内存管理改变的有:

#### ①. 转换物理地址方式

在没有开启分页机制时，由程序员给出的**逻辑地址**，需要先通过分段机制转换成物理地址。但在开启分页机制后，逻辑地址仍然要先通过分段机制进行转换，只不过转换后不再是最终的物理地址，而是**线性地址**，然后再通过一次分页机制转换，得到最终的物理地址。

![](D:\Issues\system\linux\head2.png)

#### ②. 内存变化

和具体分页机制中, 线性地址转换说明

![](D:\Issues\system\linux\head3.png)

分为三部分:
高 10 位 **页目录表**：中间 10 位 **页表**：后 12 位 **偏移地址**
高 10 位负责在**页目录表**中找到一个**页目录项**，这个页目录项的值加上中间 10 位拼接后的地址去**页表**中去寻找一个**页表项**，这个页表项的值，再加上后 12 位偏移地址，就是最终的物理地址。 这一切由MMU操作.

### 3. 设置页目录表结构

当时 linux-0.11 认为，总共可以使用的内存不会超过 **16M**，也即最大地址空间为 **0xFFFFFF**。总大小即:
4（页表数）* 1024（页表项数） * 4KB（一页大小）= 16MB

![](D:\Issues\system\linux\head5.png)

### 4.  将页目录表放在0地址

并将页目录表地址写入cr3寄存器

![](D:\Issues\system\linux\head4.png)

然后压栈main, 跳转main

## 五. 内存管理

Intel 体系结构的**内存管理**可以分成两大部分，也就是标题中的两板斧，**分段**和**分页**。

### **分段机制**:

在之前几回已经讨论过多次了，其目的是为了为每个程序或任务提供单独的代码段（cs）、数据段（ds）、栈段（ss），使其不会相互干扰。

### **分页机制**:

是本回讲的内容，开机后分页机制默认是关闭状态，需要我们手动开启，并且设置好页目录表（PDE）和页表（PTE）。其目的在于可以按需使用物理内存，同时也可以在多任务时起到隔离的作用，这个在后面将多任务时将会有所体会。

在 Intel 的保护模式下，分段机制是没有开启和关闭一说的，它必须存在，而分页机制是可以选择开启或关闭的。所以如果有人和你说，它实现了一个没有分段机制的操作系统，那一定是个外行。

## 六. 再说说那些地址：

### **逻辑地址**：

我们程序员写代码时给出的地址叫逻辑地址，其中包含段选择子和偏移地址两部分。

### **线性地址**：

通过分段机制，将逻辑地址转换后的地址，叫做线性地址。而这个线性地址是有个范围的，这个范围就叫做线性地址空间，32 位模式下，线性地址空间就是 4G。

### **物理地址**：

就是真正在内存中的地址，它也是有范围的，叫做物理地址空间。那这个范围的大小，就取决于你的内存有多大了。

### **虚拟地址**：

如果没有开启分页机制，那么线性地址就和物理地址是一一对应的，可以理解为相等。如果开启了分页机制，那么线性地址将被视为虚拟地址，这个虚拟地址将会通过分页机制的转换，最终转换成物理地址。

## 七. main

### 1. 获取初始化参数

使用从 [三. setup.s](#三. setup.s) 中获取的参数:

### 2. 初始化操作

### 	①. 内存初始化 mem_init

​		准备了一个表mem_map，记录了哪些内存被占用了，哪些内存没被占用

### 	②. 初始化中断 trap_init

​		为每个中断号设置相应**特权级**并注册处理程序
​		打开中断使能

### 	③. 读取硬盘数据到内存 blk_dev_init

​		什么设备: 硬盘
​		什么操作: 读
​		从哪里读: 2-5扇区
​		读到哪里: 内存 0x90000

### ④. 初始化字符设备 tty_init

​		开启串口中断
​		选择显示模式: 这里例句终端显示模式
​			第一: 获取该模式相关信息
​			第二: 根据获取的信息把显存映射到内存
​			第三: 滚动屏幕操作时信息
​			第四: 定位光标并开启键盘中断

### ⑤. 初始化时间 time_init

​		读取外设CMOS信息, 转化为时间信息

### ⑥. 进程调度初始化shed_init, 多进程的开始

​		第一: (往全局描述符表GDT后添加)初始化TSS 和 LDT
​		**TSS**:任务状态段, 就是**保存和恢复进程的上下文的**，所谓上下文，其实就是各个寄存器的信息而已，这样进程切换的时候，才能做到保存和恢复上下文，继续执行。
​		**LDT**:局部描述符表, 是与 GDT 全局描述符表相对应的，内核态的代码用 GDT 里的数据段和代码段，而用户进程的代码用每个用户进程自己的 LDT 里得数据段和代码段。

​		第二: 初始化创建进程所需信息, tr寄存器指向TSS, ldt寄存器指向LDT

​		第三: 设置时钟中断, 系统中断, 一个进程调度的起点，一个作为用户程序调用操作系统功能的桥梁



### 3. 切换到用户态模式

### 	①. 设置终端标准IO

### 	②. 打开终端

